////////////////////////////////////////////////////////////////////////////////
//	DESC:	A nearest neighbor algorithm module.
//
//	Some basic things to be set:
//   MPIFLAG: set this to 1
//   NN_POPULATION: this is the number of tours generated by EACH node.
//    example: if you have 3 nodes, 25 cities, and NN_POPULATION is 10, then
//     node0 will generate with cities offset 0-9,
//     node1 will generate with cities offset 10-19,
//     node2 will generate with cities offset 20-24,0-4
//	All nodes will then sort their populations and send their most fit tour
//	to master.
////////////////////////////////////////////////////////////////////////////////

#include "include/tsp.h"
#include "include/eax.h"

//// GLOBAL VARIABLES //////////////////////////////////////////////////////////
#define NN_POPULATION MAX_POPULATION /*	this is the max population for the
								nearest neighbor code. so, each node
								will construct NN_POPULATION tours. */

// "global" variables. I try to start these with capital letters
tour_t *CitiesA, *CitiesB; /*	the "tour" that contains every city in their
						provided order. Not really a tour, just used as 
						the master array of cities. */
tour_t** Tours, **childrenTours; /*	all of the current tours
								in the population. */
int randSeed = 0;
char* citiesFile = 0;
char* toursFile = 0;
char* dataSet = 0;
char* outputPrefix = 0;
int mpi_rank = 0;
int numFileTours=0;

time_t startTime; // time the program started running
int* intTours;
int* intCities;
#if BEST_TOUR_TRACKING
tour_t** BestTours; // array containing the best tours
int sizeBestTours; // how many best tours there are
tour_t* lastBestTour;  // the previous best tour, last iteration
#endif
////////////////////////////////////////////////////////////////////////////////


/**
 * DESC: Fills the population of tours with an initial set of tours.
 *
 * N : size of each tour.
 * mpi_rank : rank of the mpi process
 * arr_tours : an array of pointers to tours
 *		(the array must be allocated, each tour should not)
 * arr_cities : the master Cities structure
 */
void populate_tours(int N, int mpi_rank, tour_t** arr_tours, tour_t* arr_cities)
{
	int i=0;
	int city_offset = mpi_rank * NN_POPULATION;
	while (i<NN_POPULATION)
	{
		// the old tour generation
		arr_tours[i] = create_tour_nn(arr_cities->city[city_offset%N], N,
			arr_cities);
		set_tour_fitness(arr_tours[i], N);
		i++;
		city_offset++;
	}
}


//// BEST TOUR TRACKING ////////////////////////////////////////////////////////
#if BEST_TOUR_TRACKING
void initBestTourTracking()
{
	
}

void dumpBestTours()
{
	
}

/**
 * DESC: Pass in current best tour for tracking.
 */
void trackTours(tour_t** allTours)
{
	static int iteration = 0;
	int i, a;
	
	// dump all of the current tours to disk
	char buffer[50];
	sprintf(buffer, "%s%s_%03i", "output/", outputPrefix, iteration++);
	FILE* dump = fopen(buffer, "w");
	
	// write it to disk
	fprintf(dump, "%i %i\n", NUM_TOP_TOURS, allTours[0]->size);
	for (i=0; i < NUM_TOP_TOURS; i++)
	{
		fprintf(dump, "%i", allTours[i]->city[0]->id);
		for (a=1; a < allTours[i]->size; a++)
		{
			fprintf(dump, "+%i", allTours[i]->city[a]->id);
		}// for each city
		fprintf(dump, "\n");
	}// for each tour
	
	// close the file
	fclose(dump);
	
	// submission script
#if SUBMIT_TO_SERVER
	sprintf(buffer, "%s %s output/%s_%03i", "python scripts/mapping.py",
		dataSet, outputPrefix, iteration-1);
	system(buffer);
#else
	OOPS_TEXT;
	printf("SUBMISSION_TO_SERVER IS TURNED OFF, NOT SUBMITTING TO SERVER.\n");
	NORMAL_TEXT;
#endif
}
#endif
//// END BEST TOUR TRACKING ////////////////////////////////////////////////////


/**
 * DESC: Initializes the MPI procedures/variables.
 */
void MPI_init(int *mpi_rank, int *mpi_procs, int *argc, char ***argv)
{
	MPI_Init(argc,argv);
	MPI_Comm_rank(MPI_COMM_WORLD,mpi_rank);
	MPI_Comm_size(MPI_COMM_WORLD,mpi_procs);
	DPRINTF("Just set up MPI on rank %i!\n",*mpi_rank);
}

/**
 * DESC: main method for the entire program. This is what gets called first.
 */
int main(int argc, char** argv)
{
	startTime = time(0);
	int i; // loop counter
	int mpi_procs; // mpi rank (for each process) and number of processes
	char lcv = 1; /* 	loop control variable for the while loop
					(run until lcv->0) */
	MPI_Status status;
	intTours = 0;
	intCities = 0;

	mpi_procs = 1;
	

	//#########################################################################
	// Argument Handler
	//#########################################################################
	// check number of parameters
	if (argc < 2)
	{
		printf("Usage: %s [flags] <filename of cities text document>\n",
			argv[0]);
		printf("Try -h or --help for more information.\n");
		terminate_program(1); // ERROR: must supply a filename for the cities
	}
	else // process params
	{
		for (i=1; i < argc; i++)
		{
			char* p = argv[i];
			if (strcmp(p, "-h") == 0 || strcmp(p, "-H") == 0 ||
				strcmp(p, "--help") == 0 ||strcmp(p, "--HELP") == 0)
			{
				printf("Usage: %s [flags] <filename of cities text document>\n", argv[0]);
				printf(" -- File Format Explanation --\n");
				printf("  The first line of the cities text document is the number of cities.\n");
				printf("  The following lines are each city. 2 integers, space separated, are the x and y of that city. Example: \n");
				printf("  23 45\n");
				printf(" -- optional flags --\n");
				printf("-h, --help : this screen.\n");
				printf("-s <random seed> : random seed to initialize srand with.\n");
				printf("-t <tours file> : loads a file containing tours (must match your dataset).\n");
				printf("-d <dataSetName> : this is the \"name\" of the dataset, not the file name, but the name you pass into submission.\n");
			}
			else if (strcmp(p, "-d") == 0)
			{
				// dataSet
				dataSet = argv[++i];
			}
			else if (strcmp(p, "-o") == 0)
			{
				// outputPrefix
				outputPrefix = argv[++i];
			}
			else if (strcmp(p, "-s") == 0)
			{
				// random seed
				randSeed = atoi(argv[++i]);
			}
			else if (strcmp(p, "-t") == 0)
			{
				// set tours file
				toursFile = argv[++i];
			}
			else
			{
				citiesFile = argv[i];
			}// else filename
		}// for each argument
	}// else process the arguments
	// check to make sure we got a city file
	if (!citiesFile)
	{
		printf("no city file present. halting\n");
		terminate_program(3); // ERROR: no city file present
	}
	// init outputPrefix
	if (!outputPrefix)
	{
		OOPS_TEXT;
		printf("No data set name loaded.\n");
		NORMAL_TEXT;
		outputPrefix = "NONAME";
	}
	else
	{
		printf("outputPrefix: '%s'\n", outputPrefix);
	}
	// initialize srand
	if (randSeed)
	{
		DPRINTF("Using \033[31m%i\033[0m as random seed.\n", randSeed);
		srand(randSeed);
	}
	else // otherwise use a random seed
	{
		randSeed = time(0);
		DPRINTF("Picked a random seed (\033[31m%i\033[0m).\n", randSeed);
		srand(randSeed*(mpi_rank+1));
		DPRINTF("seed done.\n");
	}

	// set up MPI
	MPI_init(&mpi_rank,&mpi_procs,&argc,&argv);

	//#########################################################################
	// Load Cities, Initialize Tables, Create Init tours
	//#########################################################################
	// load the cities

	int *intCities = malloc(MAX_CITIES * sizeof(int) * 3);
	if (MPIFLAG==1)
	{
#if MPIFLAG

		// If MPI active, then let the master load cities and broadcast
		if (mpi_rank==0)
		{
			load_cities(mpi_rank, citiesFile, &CitiesA);
			load_cities(mpi_rank, citiesFile, &CitiesB);

			// MPI Send cities
			city_tToInt(CitiesA, CitiesA->size, intCities);

			for (i=1;i<mpi_procs;i++)
			{
				DPRINTF("Master sends city size to %i\n",i);
				MPI_Send(&(CitiesA->size), 1, MPI_INT, i, MPI_TAG,
					MPI_COMM_WORLD);
				DPRINTF("Master sends tours to %i\n",i);
				MPI_Send(intCities, CitiesA->size*3, MPI_INT, i, MPI_TAG,
					MPI_COMM_WORLD);
			}

		}
		else
		{
			// MPI Receive cities
			CitiesA = malloc(sizeof(tour_t));
			CitiesB = malloc(sizeof(tour_t));
			DPRINTF("Island receiving citysize...CitiesA: %x ->size: %i\n",
				CitiesA, (CitiesA?CitiesA->size:-1));
			MPI_Recv(&(CitiesA->size), 1, MPI_INT, 0, MPI_TAG,
				MPI_COMM_WORLD, &status);
			CitiesB->size = CitiesA->size;
			DPRINTF("Got city size of %i!\n",CitiesA->size);
			// receive actual array of cities as intarray
			DPRINTF("Island waiting for cities...\n");
			// size of intCities has x, y, id values.
			MPI_Recv(intCities, CitiesA->size*3, MPI_INT, 0, MPI_TAG,
				MPI_COMM_WORLD, &status);
			DPRINTF("Island got cities!\n");
			// malloc the cities in the array
			for (i=0;i<CitiesA->size;i++)
			{
				CitiesA->city[i]=malloc(sizeof(city_t));
				CitiesB->city[i]=malloc(sizeof(city_t));
			}
			// convert the int array to a city array
			intToCity_t(intCities, CitiesA->size, CitiesA);
			intToCity_t(intCities, CitiesB->size, CitiesB);
			DPRINTF("Cities converted. Now printing...\n");
			print_tour(CitiesA);
			print_tour(CitiesB);
			DPRINTF("Done printing!\n");
		}
#endif
	}
	else
	{
		// Otherwise, just load the cities.
		load_cities(mpi_rank, citiesFile, &CitiesA);
		load_cities(mpi_rank, citiesFile, &CitiesB);
	}
	// process the cities
	DPRINTF("Set up cities\n");
	int N = CitiesA->size;
	for (i=0; i < CitiesA->size; i++)
	{
		CitiesA->city[i]->tour = TOUR_A;
		CitiesB->city[i]->tour = TOUR_B;
	}
	// allocate memory for Tours and children_tours
	DPRINTF("Allocating tours array\n");
	Tours = malloc( sizeof(tour_t*) * MAX_POPULATION );

	// construct the distance table (on all processes)
#if USE_DISTANCE_TABLE
	construct_distTable(CitiesA,N);
#else
	DPRINTF("Not using a distance table.\n");
#endif

	// populate tours (on all processes)
	populate_tours(N,mpi_rank,Tours,CitiesA);
	sortTours(Tours,NN_POPULATION);
	int *tempIntTour=malloc(sizeof(int)*3*CitiesA->size);
	if (mpi_rank==0)
	{
		tour_t* tempTour=(tour_t*)malloc(sizeof(tour_t));
		// master receives the best tours
		for (i=1;i<mpi_procs;i++)
		{
			MPI_Recv(tempIntTour, CitiesA->size*3, MPI_INT, i, MPI_TAG,
				MPI_COMM_WORLD, &status);
			intToTour_t(CitiesA, tempIntTour, 1, &tempTour);
			mergeTourToPop(Tours, 1, tempTour);
		}
		trackTours(Tours);
	}
	else
	{
		// slaves send their best tour
		tour_tToInt(&Tours[0],1,tempIntTour);
		MPI_Send(tempIntTour, CitiesA->size*3, MPI_INT, 0, MPI_TAG,
			MPI_COMM_WORLD);
	}

	//#########################################################################
	// Print all tours to console.
	//#########################################################################
	if (mpi_rank==0)
		for (i=0;i<NN_POPULATION;i++)
			print_tour(Tours[i]);
	// TODO: send these best tours to a file.

	//#########################################################################
	// Free Memory, Terminate Program
	//#########################################################################
	terminate_program(0);
}
